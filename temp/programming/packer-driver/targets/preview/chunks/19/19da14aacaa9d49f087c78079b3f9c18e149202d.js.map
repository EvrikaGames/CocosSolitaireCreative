{"version":3,"sources":["file:///D:/Cocos/CocosWordLineCreative/assets/scripts/wordConnect/spelling/SpellingView.ts"],"names":["_decorator","Component","Node","Vec3","instantiate","SpellingLetter","SpellingVariant","ccclass","property","SpellingView","type","letterXSize","letterXOffset","letters","set","word","variants","correctVariantIndex","placeLetters","length","i","onLoad","forEach","v","node","on","SELECTED_EVENT","onVariantSelected","onDestroy","off","event","index","emit","VARIANT_SELECTED","uncoverWord","lettersTweens","map","l","scaleTween","block","isBlocked","pop","destroy","letter","letterPrefab","active","parent","lettersRoot","push","getComponent","offset","spawnX","setPosition"],"mappings":"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","sourcesContent":["import { _decorator, Component, Tween, Node, Vec3, instantiate } from 'cc';\r\nimport { SpellingLetter } from './SpellingLetter';\r\nimport { SpellingVariant } from './SpellingVariant';\r\nconst { ccclass, property } = _decorator;\r\n\r\n@ccclass('SpellingView')\r\nexport class SpellingView extends Component {\r\n\r\n    public static readonly VARIANT_SELECTED = \"variant_selected\";\r\n\r\n    @property({type:Node})\r\n    private lettersRoot = null;\r\n\r\n    @property({type:Node})\r\n    private letterPrefab = null;\r\n\r\n    @property([SpellingVariant])\r\n    private variants: SpellingVariant[] = [];\r\n    \r\n    private letterXSize: number = 85;\r\n    private letterXOffset: number = 10;\r\n\r\n    private letters: SpellingLetter[] = [];\r\n\r\n    set(word: string, variants: string[], correctVariantIndex: number) {\r\n\r\n        this.placeLetters(word.length);\r\n        \r\n        for (let i = 0; i < word.length; i++) {\r\n            this.letters[i].set(word[i]);\r\n        }\r\n        \r\n        for (let i = 0; i < this.variants.length; i++) {\r\n            this.variants[i].set(variants[i], i, i == correctVariantIndex);\r\n        }\r\n    }\r\n\r\n    onLoad() {\r\n        this.variants.forEach(v => {\r\n            v.node.on(SpellingVariant.SELECTED_EVENT, this.onVariantSelected, this);\r\n        });\r\n    }\r\n\r\n    onDestroy() {\r\n        this.variants.forEach(v => {\r\n            v.node.off(SpellingVariant.SELECTED_EVENT, this.onVariantSelected, this);\r\n        });\r\n    }\r\n\r\n    onVariantSelected(event) {\r\n\r\n        const index = event.index;\r\n        this.node.emit(SpellingView.VARIANT_SELECTED, { index: index });\r\n    }\r\n\r\n    uncoverWord(word: string) : Tween<Node>[] {\r\n\r\n        let lettersTweens = this.letters.map((l, i) => {\r\n            return l.scaleTween(word[i], i * 0.25);\r\n        });\r\n\r\n        return lettersTweens;\r\n    }\r\n\r\n    block(isBlocked: boolean) {\r\n        this.variants.forEach(v => {\r\n            v.block(isBlocked);\r\n        })\r\n    }\r\n\r\n    private placeLetters(length: number) {\r\n\r\n        while (this.letters.length > length) {\r\n            this.letters.pop().node.destroy();\r\n        }\r\n\r\n        while (this.letters.length < length) {\r\n            let letter = instantiate(this.letterPrefab);\r\n            letter.active = true;\r\n            letter.parent = this.lettersRoot;\r\n            this.letters.push(letter.getComponent(SpellingLetter));\r\n        }\r\n\r\n        const offset = this.letterXSize + this.letterXOffset;\r\n        const spawnX = (this.letters.length - 1) * (offset) / -2;\r\n\r\n        for (let i = 0; i < this.letters.length; i++) {\r\n            const letter = this.letters[i];\r\n            \r\n            letter.node.setPosition(new Vec3(spawnX + i * offset, 0, 0));\r\n        }\r\n    }\r\n}\r\n"]}